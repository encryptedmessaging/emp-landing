
<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<title>The Go Programming Language Blog</title>
	<link type="text/css" rel="stylesheet" href="/lib/godoc/style.css">
	<link rel="alternate" type="application/atom+xml" title="blog.golang.org - Atom Feed" href="//blog.golang.org/feed.atom" />
	<script type="text/javascript">window.initFuncs = [];</script>
	<style>
		#sidebar {
			float: right;
			padding-left: 20px;
			width: 250px;
			background: white;
		}
		#sidebar p, #sidebar ul {
			margin: 20px 5px;
		}
		#sidebar ul {
			padding: 0;
		}
		#sidebar li {
			list-style-type: none;
		}
		#content .author {
			font-style: italic;
		}
		#content .article {
			margin-bottom: 50px;
		}
		#content .date {
			color: #999;
		}
		#content .tags {
			color: #999;
			font-size: smaller;
		}
		#content .iframe, #content .image {
			margin: 20px;
		}
		#content .title {
			margin: 20px 0;
		}
	</style>
<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(["_setAccount", "UA-11222381-3"]);
_gaq.push(["b._setAccount", "UA-49880327-6"]);
window.trackPageview = function() {
  _gaq.push(["_trackPageview", location.pathname+location.hash]);
  _gaq.push(["b._trackPageview", location.pathname+location.hash]);
};
window.trackPageview();
</script>
</head>
<body>

<div id="topbar"><div class="container">

<form method="GET" action="//golang.org/search">
<div id="menu">
<a href="//golang.org/doc/">Documents</a>
<a href="//golang.org/pkg/">Packages</a>
<a href="//golang.org/project/">The Project</a>
<a href="//golang.org/help/">Help</a>
<a href="/">Blog</a>
<input type="text" id="search" name="q" class="inactive" value="Search" placeholder="Search">
</div>
<div id="heading"><a href="//golang.org/">The Go Programming Language</a></div>
</form>

</div></div>

<div id="page">
<div class="container">

<div id="sidebar">
	
	
	<h4>Links</h4>
	<ul>
	<li><a href='//golang.org/'>golang.org</a></li>
	<li><a href='//golang.org/doc/install.html'>Install Go</a></li>
	<li><a href='//tour.golang.org/'>A Tour of Go</a></li>
	<li><a href='//golang.org/doc/'>Go Documentation</a></li>
	<li><a href='//groups.google.com/group/golang-nuts'>Go Mailing List</a></li>
	<li><a href='//plus.google.com/101406623878176903605'>Go on Google+</a></li>
	<li><a href='//plus.google.com/112164155169467723645/posts'>Go+ Community</a></li>
	<li><a href='//twitter.com/golang'>Go on Twitter</a></li>
	</ul>
	
	<p><a href="/index">Blog index</a></p>
</div>

<div id="content">
	<h1><a href="/">The Go Blog</a></h1>
	
	
		
	<div class="article">
		<h3 class="title"><a href="/constants">Constants</a></h3>
		<p class="date">25 August 2014</p>
		

  
  
    
      
  <h4 id="TOC_1.">Introduction</h4>
  
  
  <p>
    Go is a statically typed language that does not permit operations that mix numeric types.


    You can&#39;t add a <code>float64</code> to an <code>int</code>, or even an <code>int32</code> to an <code>int</code>.


    Yet it is legal to write <code>1e6*time.Second</code> or <code>math.Exp(1)</code> or even <code>1&lt;&lt;(&#39;\t&#39;+2.0)</code>.


    In Go, constants, unlike variables, behave pretty much like regular numbers.


    This post explains why that is and what it means.
  </p>
  


    
      
  <h4 id="TOC_2.">Background: C</h4>
  
  
  <p>
    In the early days of thinking about Go, we talked about a number of problems caused by the way C and its descendants let you mix and match numeric types.


    Many mysterious bugs, crashes, and portability problems are caused by expressions that combine integers of different sizes and &#34;signedness&#34;.


    Although to a seasoned C programmer the result of a calculation like
  </p>
  

  
  <div class="code"><pre>unsigned int u = 1e9;
long signed int i = -1;
... i &#43; u ...</pre></div>
  

  
  <p>
    may be familiar, it isn&#39;t <i>a priori</i> obvious.


    How big is the result?


    What is its value?


    Is it signed or unsigned?
  </p>
  

  
  <p>
    Nasty bugs lurk here.
  </p>
  

  
  <p>
    C has a set of rules called &#34;the usual arithmetic conversions&#34; and it is an indicator of their subtlety that they have changed over the years (introducing yet more bugs, retroactively).
  </p>
  

  
  <p>
    When designing Go, we decided to avoid this minefield by mandating that there is <i>no</i> mixing of numeric types.


    If you want to add <code>i</code> and <code>u</code>, you must be explicit about what you want the result to be.


    Given
  </p>
  

  
  <div class="code"><pre>var u uint
var i int</pre></div>
  

  
  <p>
    you can write either <code>uint(i)+u</code> or <code>i+int(u)</code>, with both the meaning and type of the addition clearly expressed, but unlike in C you cannot write <code>i+u</code>.


    You can&#39;t even mix <code>int</code> and <code>int32</code>, even when <code>int</code> is a 32-bit type.
  </p>
  

  
  <p>
    This strictness eliminates a common cause of bugs and other failures.


    It is a vital property of Go.


    But it has a cost: it sometimes requires programmers to decorate their code with clumsy numeric conversions to express their meaning clearly.
  </p>
  

  
  <p>
    And what about constants?


    Given the declarations above, what would make it legal to write <code>i</code> <code>=</code> <code>0</code> or <code>u</code> <code>=</code> <code>0</code>?


    What is the <i>type</i> of <code>0</code>?


    It would be unreasonable to require constants to have type conversions in simple contexts such as <code>i</code> <code>=</code> <code>int(0)</code>.
  </p>
  

  
  <p>
    We soon realized the answer lay in making numeric constants work differently from how they behave in other C-like languages.


    After much thinking and experimentation, we came up with a design that we believe feels right almost always, freeing the programmer from converting constants all the time yet being able to write things like <code>math.Sqrt(2)</code> without being chided by the compiler.
  </p>
  

  
  <p>
    In short, constants in Go just work, most of the time anyway.


    Let&#39;s see how that happens.
  </p>
  


    
      
  <h4 id="TOC_3.">Terminology</h4>
  
  
  <p>
    First, a quick definition.


    In Go, <code>const</code> is a keyword introducing a name for a scalar value such as <code>2</code> or <code>3.14159</code> or <code>&#34;scrumptious&#34;</code>.


    Such values, named or otherwise, are called <i>constants</i> in Go.


    Constants can also be created by expressions built from constants, such as <code>2+3</code> or <code>2+3i</code> or <code>math.Pi/2</code> or <code>(&#34;go&#34;+&#34;pher&#34;)</code>.
  </p>
  

  
  <p>
    Some languages don&#39;t have constants, and others have a more general definition of constant or application of the word <code>const</code>.


    In C and C++, for instance, <code>const</code> is a type qualifier that can codify more intricate properties of more intricate values.
  </p>
  

  
  <p>
    But in Go, a constant is just a simple, unchanging value, and from here on we&#39;re talking only about Go.
  </p>
  


    
      
  <h4 id="TOC_4.">String constants</h4>
  
  
  <p>
    There are many kinds of numeric constants—integers, floats, runes, signed, unsigned, imaginary, complex—so let&#39;s start with a simpler form of constant: strings.


    String constants are easy to understand and provide a smaller space in which to explore the type issues of constants in Go.
  </p>
  

  
  <p>
    A string constant encloses some text between double quotes.


    (Go has also has raw string literals, enclosed by backquotes <code>``</code>, but for the purpose of this discussion they have all the same properties.)


    Here is a string constant:
  </p>
  

  
  <div class="code"><pre>&#34;Hello, 世界&#34;</pre></div>
  

  
  <p>
    (For much more detail about the representation and interpretation of strings, see <a href="//blog.golang.org/strings" target="_self">this blog post</a>.)
  </p>
  

  
  <p>
    What type does this string constant have?


    The obvious answer is <code>string</code>, but that is <i>wrong</i>.
  </p>
  

  
  <p>
    This is an <i>untyped string constant</i>, which is to say it is a constant textual value that does not yet have a fixed type.


    Yes, it&#39;s a string, but it&#39;s not a Go value of type <code>string</code>.


    It remains an untyped string constant even when given a name:
  </p>
  

  
  <div class="code"><pre>const hello = &#34;Hello, 世界&#34;</pre></div>
  

  
  <p>
    After this declaration, <code>hello</code> is also an untyped string constant.


    An untyped constant is just a value, one not yet given a defined type that would force it to obey the strict rules that prevent combining differently typed values.
  </p>
  

  
  <p>
    It is this notion of an <i>untyped</i> constant that makes it possible for us to use constants in Go with great freedom.
  </p>
  

  
  <p>
    So what, then, is a <i>typed</i> string constant?


    It&#39;s one that&#39;s been given a type, like this:
  </p>
  

  
  <div class="code"><pre>const typedHello string = &#34;Hello, 世界&#34;</pre></div>
  

  
  <p>
    Notice that the declaration of <code>typedHello</code> has an explicit <code>string</code> type before the equals sign.


    This means that <code>typedHello</code> has Go type <code>string</code>, and cannot be assigned to a Go variable of a different type.


    That is to say, this code works:
  </p>
  

  
	<div class="playground">
<pre style="display: none"><span>// &#43;build OMIT

package main

import &#34;fmt&#34;

const typedHello string = &#34;Hello, 世界&#34;

func main() {
</span></pre>

<pre contenteditable="true" spellcheck="false"><span num="11">    var s string</span>
<span num="12">    s = typedHello</span>
<span num="13">    fmt.Println(s)</span>
</pre>

<pre style="display: none"><span>}
</span></pre>
</div>
  

  
  <p>
    but this does not:
  </p>
  

  
	<div class="playground">
<pre style="display: none"><span>// &#43;build OMIT

package main

import &#34;fmt&#34;

const typedHello string = &#34;Hello, 世界&#34;

func main() {
</span></pre>

<pre contenteditable="true" spellcheck="false"><span num="11">    type MyString string</span>
<span num="12">    var m MyString</span>
<span num="13">    m = typedHello // Type error</span>
<span num="14">    fmt.Println(m)</span>
</pre>

<pre style="display: none"><span>}
</span></pre>
</div>
  

  
  <p>
    The variable <code>m</code> has type <code>MyString</code> and cannot be assigned a value of a different type.


    It can only be assigned values of type <code>MyString</code>, like this:
  </p>
  

  
	<div class="playground">
<pre style="display: none"><span>// &#43;build OMIT

package main

import &#34;fmt&#34;

const typedHello string = &#34;Hello, 世界&#34;

func main() {
	type MyString string
	var m MyString
</span></pre>

<pre contenteditable="true" spellcheck="false"><span num="13">    const myStringHello MyString = &#34;Hello, 世界&#34;</span>
<span num="14">    m = myStringHello // OK</span>
<span num="15">    fmt.Println(m)</span>
</pre>

<pre style="display: none"><span>}
</span></pre>
</div>
  

  
  <p>
    or by forcing the issue with a conversion, like this:
  </p>
  

  
	<div class="playground">
<pre style="display: none"><span>// &#43;build OMIT

package main

import &#34;fmt&#34;

const typedHello string = &#34;Hello, 世界&#34;

func main() {
	type MyString string
	var m MyString
</span></pre>

<pre contenteditable="true" spellcheck="false"><span num="13">    m = MyString(typedHello)</span>
<span num="14">    fmt.Println(m)</span>
</pre>

<pre style="display: none"><span>}
</span></pre>
</div>
  

  
  <p>
    Returning to our <i>untyped</i> string constant, it has the helpful property that, since it has no type, assigning it to a typed variable does not cause a type error.


    That is, we can write
  </p>
  

  
  <div class="code"><pre>m = &#34;Hello, 世界&#34;</pre></div>
  

  
  <p>
    or
  </p>
  

  
  <div class="code"><pre>m = hello</pre></div>
  

  
  <p>
    because, unlike the typed constants <code>typedHello</code> and <code>myStringHello</code>, the untyped constants <code>&#34;Hello, 世界&#34;</code> and <code>hello</code> <i>have no type</i>.


    Assigning them to a variable of any type compatible with strings works without error.
  </p>
  

  
  <p>
    These untyped string constants are strings, of course, so they can only be used where a string is allowed, but they do not have <i>type</i> <code>string</code>.
  </p>
  


    
      
  <h4 id="TOC_5.">Default type</h4>
  
  
  <p>
    As a Go programmer, you have certainly seen many declarations like
  </p>
  

  
  <div class="code"><pre>str := &#34;Hello, 世界&#34;</pre></div>
  

  
  <p>
    and by now you might be asking, &#34;if the constant is untyped, how does <code>str</code> get a type in this variable declaration?&#34;


    The answer is that an untyped constant has a default type, an implicit type that it transfers to a value if a type is needed where none is provided.


    For untyped string constants, that default type is obviously <code>string</code>, so
  </p>
  

  
  <div class="code"><pre>str := &#34;Hello, 世界&#34;</pre></div>
  

  
  <p>
    or
  </p>
  

  
  <div class="code"><pre>var str = &#34;Hello, 世界&#34;</pre></div>
  

  
  <p>
    means exactly the same as
  </p>
  

  
  <div class="code"><pre>var str string = &#34;Hello, 世界&#34;</pre></div>
  

  
  <p>
    One way to think about untyped constants is that they live in a kind of ideal space of values, a space less restrictive than Go&#39;s full type system.


    But to do anything with them, we need to assign them to variables, and when that happens the <i>variable</i> (not the constant itself) needs a type, and the constant can tell the variable what type it should have.


    In this example, <code>str</code> becomes a value of type <code>string</code> because the untyped string constant gives the declaration its default type, <code>string</code>.
  </p>
  

  
  <p>
    In such a declaration, a variable is declared with a type and initial value.


    Sometimes when we use a constant, however, the destination of the value is not so clear.


    For instance consider this statement:
  </p>
  

  
	<div class="playground">
<pre style="display: none"><span>// &#43;build OMIT

package main

import &#34;fmt&#34;

func main() {
</span></pre>

<pre contenteditable="true" spellcheck="false"><span num="9">    fmt.Printf(&#34;%s&#34;, &#34;Hello, 世界&#34;)</span>
</pre>

<pre style="display: none"><span>}
</span></pre>
</div>
  

  
  <p>
    The signature of <code>fmt.Printf</code> is
  </p>
  

  
  <div class="code"><pre>func Printf(format string, a ...interface{}) (n int, err error)</pre></div>
  

  
  <p>
    which is to say its arguments (after the format string) are interface values.


    What happens when <code>fmt.Printf</code> is called with an untyped constant is that an interface value is created


    to pass as an argument, and the concrete type stored for that argument is the default type of the constant.


    This process is analogous to what we saw earlier when declaring an initialized value using an untyped string constant.
  </p>
  

  
  <p>
    You can see the result in this example, which uses the format <code>%v</code> to print the value and <code>%T</code> to print the type of the value being passed to <code>fmt.Printf</code>:
  </p>
  

  
	<div class="playground">
<pre style="display: none"><span>// &#43;build OMIT

package main

import &#34;fmt&#34;

const hello = &#34;Hello, 世界&#34;

func main() {
</span></pre>

<pre contenteditable="true" spellcheck="false"><span num="11">    fmt.Printf(&#34;%T: %v\n&#34;, &#34;Hello, 世界&#34;, &#34;Hello, 世界&#34;)</span>
<span num="12">    fmt.Printf(&#34;%T: %v\n&#34;, hello, hello)</span>
</pre>

<pre style="display: none"><span>}
</span></pre>
</div>
  

  
  <p>
    If the constant has a type, that goes into the interface, as this example shows:
  </p>
  

  
	<div class="playground">
<pre style="display: none"><span>// &#43;build OMIT

package main

import &#34;fmt&#34;

type MyString string

const myStringHello MyString = &#34;Hello, 世界&#34;

func main() {
</span></pre>

<pre contenteditable="true" spellcheck="false"><span num="13">    fmt.Printf(&#34;%T: %v\n&#34;, myStringHello, myStringHello)</span>
</pre>

<pre style="display: none"><span>}
</span></pre>
</div>
  

  
  <p>
    (For more information about how interface values work, see the first sections of <a href="//blog.golang.org/laws-of-reflection" target="_self">this blog post</a>.)
  </p>
  

  
  <p>
    In summary, a typed constant obeys all the rules of typed values in Go.


    On the other hand, an untyped constant does not carry a Go type in the same way and can be mixed and matched more freely.


    It does, however, have a default type that is exposed when, and only when, no other type information is available.
  </p>
  


    
      
  <h4 id="TOC_6.">Default type determined by syntax</h4>
  
  
  <p>
    The default type of an untyped constant is determined by its syntax.


    For string constants, the only possible implicit type is <code>string</code>.


    For <a href="http://golang.org/ref/spec#Numeric_types" target="_blank">numeric constants</a>, the implicit type has more variety.


    Integer constants default to <code>int</code>, floating-point constants <code>float64</code>, rune constants to <code>rune</code> (an alias for <code>int32</code>), and imaginary constants to <code>complex128</code>.


    Here&#39;s our canonical print statement used repeatedly to show the default types in action:
  </p>
  

  
	<div class="playground">
<pre style="display: none"><span>// &#43;build OMIT

package main

import &#34;fmt&#34;

func main() {
</span></pre>

<pre contenteditable="true" spellcheck="false"><span num="9">    fmt.Printf(&#34;%T %v\n&#34;, 0, 0)</span>
<span num="10">    fmt.Printf(&#34;%T %v\n&#34;, 0.0, 0.0)</span>
<span num="11">    fmt.Printf(&#34;%T %v\n&#34;, &#39;x&#39;, &#39;x&#39;)</span>
<span num="12">    fmt.Printf(&#34;%T %v\n&#34;, 0i, 0i)</span>
</pre>

<pre style="display: none"><span>}
</span></pre>
</div>
  

  
  <p>
    (Exercise: Explain the result for <code>&#39;x&#39;</code>.)
  </p>
  


    
      
  <h4 id="TOC_7.">Booleans</h4>
  
  
  <p>
    Everything we said about untyped string constants can be said for untyped boolean constants.


    The values <code>true</code> and <code>false</code> are untyped boolean constants that can be assigned to any boolean variable,


    but once given a type, boolean variables cannot be mixed:
  </p>
  

  
	<div class="playground">
<pre style="display: none"><span>// &#43;build OMIT

package main

import &#34;fmt&#34;

func main() {
</span></pre>

<pre contenteditable="true" spellcheck="false"><span num="9">    type MyBool bool</span>
<span num="10">    const True = true</span>
<span num="11">    const TypedTrue bool = true</span>
<span num="12">    var mb MyBool</span>
<span num="13">    mb = true      // OK</span>
<span num="14">    mb = True      // OK</span>
<span num="15">    mb = TypedTrue // Bad</span>
<span num="16">    fmt.Println(mb)</span>
</pre>

<pre style="display: none"><span>}
</span></pre>
</div>
  

  
  <p>
    Run the example and see what happens, then comment out the &#34;Bad&#34; line and run it again.


    The pattern here follows exactly that of string constants.
  </p>
  


    
      
  <h4 id="TOC_8.">Floats</h4>
  
  
  <p>
    Floating-point constants are just like boolean constants in most respects.


    Our standard example works as expected in translation:
  </p>
  

  
	<div class="playground">
<pre style="display: none"><span>// &#43;build OMIT

package main

import &#34;fmt&#34;

func main() {
</span></pre>

<pre contenteditable="true" spellcheck="false"><span num="9">    type MyFloat64 float64</span>
<span num="10">    const Zero = 0.0</span>
<span num="11">    const TypedZero float64 = 0.0</span>
<span num="12">    var mf MyFloat64</span>
<span num="13">    mf = 0.0       // OK</span>
<span num="14">    mf = Zero      // OK</span>
<span num="15">    mf = TypedZero // Bad</span>
<span num="16">    fmt.Println(mf)</span>
</pre>

<pre style="display: none"><span>}
</span></pre>
</div>
  

  
  <p>
    One wrinkle is that there are <i>two</i> floating-point types in Go: <code>float32</code> and <code>float64</code>.


    The default type for a floating-point constant is <code>float64</code>, although an untyped floating-point


    constant can be assigned to a <code>float32</code> value just fine:
  </p>
  

  
	<div class="playground">
<pre style="display: none"><span>// &#43;build OMIT

package main

import &#34;fmt&#34;

func main() {
	const Zero = 0.0
	const TypedZero float64 = 0.0
</span></pre>

<pre contenteditable="true" spellcheck="false"><span num="11">    var f32 float32</span>
<span num="12">    f32 = 0.0</span>
<span num="13">    f32 = Zero      // OK: Zero is untyped</span>
<span num="14">    f32 = TypedZero // Bad: TypedZero is float64 not float32.</span>
<span num="15">    fmt.Println(f32)</span>
</pre>

<pre style="display: none"><span>}
</span></pre>
</div>
  

  
  <p>
    Floating-point values are a good place to introduce the concept of overflow, or the range of values.
  </p>
  

  
  <p>
    Numeric constants live in an arbitrary-precision numeric space; they are just regular numbers.


    But when they are assigned to a variable the value must be able to fit in the destination.


    We can declare a constant with a very large value:
  </p>
  

  
	<div class="code">


<pre><span num="8">    const Huge = 1e1000</span>
</pre>


</div>
  

  
  <p>
    —that&#39;s just a number, after all—but we can&#39;t assign it or even print it. This statement won&#39;t even compile:
  </p>
  

  
	<div class="playground">
<pre style="display: none"><span>// &#43;build OMIT

package main

import &#34;fmt&#34;

func main() {
	const Huge = 1e1000
	// START OMIT
</span></pre>

<pre contenteditable="true" spellcheck="false"><span num="10">    fmt.Println(Huge)</span>
</pre>

<pre style="display: none"><span>	// STOP OMIT
}
</span></pre>
</div>
  

  
  <p>
    The error is, &#34;constant 1.00000e+1000 overflows float64&#34;, which is true.


    But <code>Huge</code> might be useful: we can use it in expressions with other constants and use the value of those expressions if the result


    can be represented in the range of a <code>float64</code>.


    The statement,
  </p>
  

  
	<div class="playground">
<pre style="display: none"><span>// &#43;build OMIT

package main

import &#34;fmt&#34;

func main() {
	const Huge = 1e1000
	// START OMIT
</span></pre>

<pre contenteditable="true" spellcheck="false"><span num="10">    fmt.Println(Huge / 1e999)</span>
</pre>

<pre style="display: none"><span>	// STOP OMIT
}
</span></pre>
</div>
  

  
  <p>
    prints <code>10</code>, as one would expect.
  </p>
  

  
  <p>
    In a related way, floating-point constants may have very high precision, so that arithmetic involving them is more accurate.


    The constants defined in the <a href="//golang.org/pkg/math" target="_self">math</a> package are given with many more digits than are


    available in a <code>float64</code>. Here is the definition of <code>math.Pi</code>:
  </p>
  

  
  <div class="code"><pre>Pi    = 3.14159265358979323846264338327950288419716939937510582097494459</pre></div>
  

  
  <p>
    When that value is assigned to a variable, some of the precision will be lost; the assignment will create the <code>float64</code> (or <code>float32</code>)


    value closest to the high-precision value. This snippet
  </p>
  

  
	<div class="playground">
<pre style="display: none"><span>// &#43;build OMIT

package main

import (
	&#34;fmt&#34;
	&#34;math&#34;
)

func main() {
</span></pre>

<pre contenteditable="true" spellcheck="false"><span num="12">    pi := math.Pi</span>
<span num="13">    fmt.Println(pi)</span>
</pre>

<pre style="display: none"><span>}
</span></pre>
</div>
  

  
  <p>
    prints <code>3.141592653589793</code>.
  </p>
  

  
  <p>
    Having so many digits available means that calculations like <code>Pi/2</code> or other more intricate evaluations can carry more precision


    until the result is assigned, making calculations involving constants easier to write without losing precision.


    It also means that there is no occasion in which the floating-point corner cases like infinities,


    soft underflows, and <code>NaNs</code> arise in constant expressions.


    (Division by a constant zero is a compile-time error, and when everything is a number there&#39;s no such thing as &#34;not a number&#34;.)
  </p>
  


    
      
  <h4 id="TOC_9.">Complex numbers</h4>
  
  
  <p>
    Complex constants behave a lot like floating-point constants.


    Here&#39;s a version of our now-familiar litany translated into complex numbers:
  </p>
  

  
	<div class="playground">
<pre style="display: none"><span>// &#43;build OMIT

package main

import &#34;fmt&#34;

func main() {
</span></pre>

<pre contenteditable="true" spellcheck="false"><span num="9">    type MyComplex128 complex128</span>
<span num="10">    const I = (0.0 &#43; 1.0i)</span>
<span num="11">    const TypedI complex128 = (0.0 &#43; 1.0i)</span>
<span num="12">    var mc MyComplex128</span>
<span num="13">    mc = (0.0 &#43; 1.0i) // OK</span>
<span num="14">    mc = I            // OK</span>
<span num="15">    mc = TypedI       // Bad</span>
<span num="16">    fmt.Println(mc)</span>
</pre>

<pre style="display: none"><span>}
</span></pre>
</div>
  

  
  <p>
    The default type of a complex number is <code>complex128</code>, the larger-precision version composed of two <code>float64</code> values.
  </p>
  

  
  <p>
    For clarity in our example, we wrote out the full expression <code>(0.0+1.0i)</code>, but this value can be shortened to <code>0.0+1.0i</code>,


    <code>1.0i</code> or even <code>1i</code>.
  </p>
  

  
  <p>
    Let&#39;s play a trick.


    We know that in Go, a numeric constant is just a number.


    What if that number is a complex number with no imaginary part, that is, a real?


    Here&#39;s one:
  </p>
  

  
	<div class="code">


<pre><span num="8">    const Two = 2.0 &#43; 0i</span>
</pre>


</div>
  

  
  <p>
    That&#39;s an untyped complex constant.


    Even though it has no imaginary part, the <i>syntax</i> of the expression defines it to have default type <code>complex128</code>.


    Therefore, if we use it to declare a variable, the default type will be <code>complex128</code>. The snippet
  </p>
  

  
	<div class="playground">
<pre style="display: none"><span>// &#43;build OMIT

package main

import &#34;fmt&#34;

func main() {
	const Two = 2.0 &#43; 0i
</span></pre>

<pre contenteditable="true" spellcheck="false"><span num="10">    s := Two</span>
<span num="11">    fmt.Printf(&#34;%T: %v\n&#34;, s, s)</span>
</pre>

<pre style="display: none"><span>}
</span></pre>
</div>
  

  
  <p>
    prints <code>complex128:</code> <code>(2+0i)</code>.


    But numerically, <code>Two</code> can be stored in a scalar floating-point number, a <code>float64</code> or <code>float32</code>, with no loss of information.


    Thus we can assign <code>Two</code> to a <code>float64</code>, either in an initialization or an assignment, without problems:
  </p>
  

  
	<div class="playground">
<pre style="display: none"><span>// &#43;build OMIT

package main

import &#34;fmt&#34;

func main() {
	const Two = 2.0 &#43; 0i
</span></pre>

<pre contenteditable="true" spellcheck="false"><span num="10">    var f float64</span>
<span num="11">    var g float64 = Two</span>
<span num="12">    f = Two</span>
<span num="13">    fmt.Println(f, &#34;and&#34;, g)</span>
</pre>

<pre style="display: none"><span>}
</span></pre>
</div>
  

  
  <p>
    The output is <code>2</code> <code>and</code> <code>2</code>.


    Even though <code>Two</code> is a complex constant, it can be assigned to scalar floating-point variables.


    This ability for a constant to &#34;cross&#34; types like this will prove useful.
  </p>
  


    
      
  <h4 id="TOC_10.">Integers</h4>
  
  
  <p>
    At last we come to integers.


    They have more moving parts—<a href="http://golang.org/ref/spec#Numeric_types" target="_blank">many sizes, signed or unsigned, and more</a>—but they play by the same rules.


    For the last time, here is our familiar example, using just <code>int</code> this time:
  </p>
  

  
	<div class="playground">
<pre style="display: none"><span>// &#43;build OMIT

package main

import &#34;fmt&#34;

func main() {
</span></pre>

<pre contenteditable="true" spellcheck="false"><span num="9">    type MyInt int</span>
<span num="10">    const Three = 3</span>
<span num="11">    const TypedThree int = 3</span>
<span num="12">    var mi MyInt</span>
<span num="13">    mi = 3          // OK</span>
<span num="14">    mi = Three      // OK</span>
<span num="15">    mi = TypedThree // Bad</span>
<span num="16">    fmt.Println(mi)</span>
</pre>

<pre style="display: none"><span>}
</span></pre>
</div>
  

  
  <p>
    The same example could be built for any of the integer types, which are:
  </p>
  

  
  <div class="code"><pre>int int8 int16 int32 int64
uint uint8 uint16 uint32 uint64
uintptr</pre></div>
  

  
  <p>
    (plus the aliases <code>byte</code> for <code>uint8</code> and <code>rune</code> for <code>int32</code>).


    That&#39;s a lot, but the pattern in the way constants work should be familiar enough by now that you can see how things will play out.
  </p>
  

  
  <p>
    As mentioned above, integers come in a couple of forms and each form has its own default type: <code>int</code> for simple constants like <code>123</code> or <code>0xFF</code> or <code>-14</code>


    and <code>rune</code> for quoted characters like &#39;a&#39;, &#39;世&#39; or &#39;\r&#39;.
  </p>
  

  
  <p>
    No constant form has as its default type an unsigned integer type.


    However, the flexibility of untyped constants means we can initialize unsigned integer variables using simple constants as long as we are clear about the type.


    It&#39;s analogous to how we can initialize a <code>float64</code> using a complex number with zero imaginary part.


    Here are several different ways to initialize a <code>uint</code>; all are equivalent, but all must mention the type explicitly for the result to be unsigned.
  </p>
  

  
  <div class="code"><pre>var u uint = 17
var u = uint(17)
u := uint(17)</pre></div>
  

  
  <p>
    Similarly to the range issue mentioned in the section on floating-point values, not all integer values can fit in all integer types.


    There are two problems that might arise: the value might be too large, or it might be a negative value being assigned to an unsigned integer type.


    For instance, <code>int8</code> has range -128 through 127, so constants outside of that range can never be assigned to a variable of type <code>int8</code>:
  </p>
  

  
	<div class="playground">
<pre style="display: none"><span>// &#43;build OMIT

package main

func main() {
	// START OMIT
</span></pre>

<pre contenteditable="true" spellcheck="false"><span num="7">    var i8 int8 = 128 // Error: too large.</span>
</pre>

<pre style="display: none"><span>	// STOP OMIT
	_ = i8
}
</span></pre>
</div>
  

  
  <p>
    Similarly, <code>uint8</code>, also known as <code>byte</code>, has range 0 through 255, so a large or negative constant cannot be assigned to a <code>uint8</code>:
  </p>
  

  
	<div class="playground">
<pre style="display: none"><span>// &#43;build OMIT

package main

func main() {
	// START OMIT
</span></pre>

<pre contenteditable="true" spellcheck="false"><span num="7">    var u8 uint8 = -1 // Error: negative value.</span>
</pre>

<pre style="display: none"><span>	// STOP OMIT
	_ = u8
}
</span></pre>
</div>
  

  
  <p>
    This type-checking can catch mistakes like this one:
  </p>
  

  
	<div class="playground">
<pre style="display: none"><span>// &#43;build OMIT

package main

func main() {
</span></pre>

<pre contenteditable="true" spellcheck="false"><span num="7">    type Char byte</span>
<span num="8">    var c Char = &#39;世&#39; // Error: &#39;世&#39; has value 0x4e16, too large.</span>
</pre>

<pre style="display: none"><span>	_ = c
}
</span></pre>
</div>
  

  
  <p>
    If the compiler complains about your use of a constant, it&#39;s likely a real bug like this.
  </p>
  


    
      
  <h4 id="TOC_11.">An exercise: The largest unsigned int</h4>
  
  
  <p>
    Here is an informative little exercise.


    How do we express a constant representing the largest value that fits in a <code>uint</code>?


    If we were talking about <code>uint32</code> rather than <code>uint</code>, we could write
  </p>
  

  
  <div class="code"><pre>const MaxUint32 = 1&lt;&lt;32 - 1</pre></div>
  

  
  <p>
    but we want <code>uint</code>, not <code>uint32</code>.


    The <code>int</code> and <code>uint</code> types have equal unspecified numbers of bits, either 32 or 64.


    Since the number of bits available depends on the architecture, we can&#39;t just write down a single value.
  </p>
  

  
  <p>
    Fans of <a href="http://en.wikipedia.org/wiki/Two&#39;s_complement" target="_blank">two&#39;s-complement arithmetic</a>,


    which Go&#39;s integers are defined to use, know that the representation of <code>-1</code> has all its bits set to 1,


    so the bit pattern of <code>-1</code> is internally the same as that of the


    largest unsigned integer.


    We therefore might think we could write
  </p>
  

  
	<div class="playground">
<pre style="display: none"><span>// &#43;build OMIT

package main

func main() {
	// START OMIT
</span></pre>

<pre contenteditable="true" spellcheck="false"><span num="7">    const MaxUint uint = -1 // Error: negative value</span>
</pre>

<pre style="display: none"><span>	// STOP OMIT
}
</span></pre>
</div>
  

  
  <p>
    but that is illegal because -1 cannot be represented by an unsigned variable; <code>-1</code> is not in the range of unsigned values.


    A conversion won&#39;t help either, for the same reason:
  </p>
  

  
	<div class="playground">
<pre style="display: none"><span>// &#43;build OMIT

package main

func main() {
	// START OMIT
</span></pre>

<pre contenteditable="true" spellcheck="false"><span num="7">    const MaxUint uint = uint(-1) // Error: negative value</span>
</pre>

<pre style="display: none"><span>	// STOP OMIT
}
</span></pre>
</div>
  

  
  <p>
    Even though at run-time a value of -1 can be converted to an unsigned integer, the rules


    for constant <a href="http://golang.org/ref/spec#Conversions" target="_blank">conversions</a> forbid this kind of coercion at compile time.


    That is to say, this works:
  </p>
  

  
	<div class="playground">
<pre style="display: none"><span>// &#43;build OMIT

package main

func main() {
</span></pre>

<pre contenteditable="true" spellcheck="false"><span num="7">    var u uint</span>
<span num="8">    var v = -1</span>
<span num="9">    u = uint(v)</span>
</pre>

<pre style="display: none"><span>	_ = u
}
</span></pre>
</div>
  

  
  <p>
    but only because <code>v</code> is a variable; if we made <code>v</code> a constant, even an untyped constant, we&#39;d be back in forbidden territory:
  </p>
  

  
	<div class="playground">
<pre style="display: none"><span>// &#43;build OMIT

package main

func main() {
</span></pre>

<pre contenteditable="true" spellcheck="false"><span num="7">    var u uint</span>
<span num="8">    const v = -1</span>
<span num="9">    u = uint(v) // Error: negative value</span>
</pre>

<pre style="display: none"><span>	_ = u
}
</span></pre>
</div>
  

  
  <p>
    We return to our previous approach, but instead of <code>-1</code> we try <code>^0</code>, the bitwise negation of an arbitrary number of zero bits.


    But that fails too, for a similar reason:


    In the space of numeric values,


    <code>^0</code> represents an infinite number of ones, so we lose information if we assign that to any fixed-size integer:
  </p>
  

  
	<div class="playground">
<pre style="display: none"><span>// &#43;build OMIT

package main

func main() {
	// START OMIT
</span></pre>

<pre contenteditable="true" spellcheck="false"><span num="7">    const MaxUint uint = ^0 // Error: overflow</span>
</pre>

<pre style="display: none"><span>	// STOP OMIT
}
</span></pre>
</div>
  

  
  <p>
    How then do we represent the largest unsigned integer as a constant?
  </p>
  

  
  <p>
    The key is to constrain the operation to the number of bits in a <code>uint</code> and avoiding


    values, such as negative numbers, that are not representable in a <code>uint</code>.


    The simplest <code>uint</code> value is the typed constant <code>uint(0)</code>.


    If <code>uints</code> have 32 or 64 bits, <code>uint(0)</code> has 32 or 64 zero bits accordingly.


    If we invert each of those bits, we&#39;ll get the correct number of one bits, which is the largest <code>uint</code> value.
  </p>
  

  
  <p>
    Therefore we don&#39;t flip the bits of the untyped constant <code>0</code>, we flip the bits of the typed constant <code>uint(0)</code>.


    Here, then, is our constant:
  </p>
  

  
	<div class="playground">
<pre style="display: none"><span>// &#43;build OMIT

package main

import &#34;fmt&#34;

func main() {
</span></pre>

<pre contenteditable="true" spellcheck="false"><span num="9">    const MaxUint = ^uint(0)</span>
<span num="10">    fmt.Printf(&#34;%x\n&#34;, MaxUint)</span>
</pre>

<pre style="display: none"><span>}
</span></pre>
</div>
  

  
  <p>
    Whatever the number of bits it takes to represent a <code>uint</code> in the current execution environment


    (on the <a href="http://blog.golang.org/playground" target="_blank">playground</a>, it&#39;s 32),


    this constant correctly represents the largest value a variable of type <code>uint</code> can hold.
  </p>
  

  
  <p>
    If you understand the analysis that got us to this result, you understand all the important points about constants in Go.
  </p>
  


    
      
  <h4 id="TOC_12.">Numbers</h4>
  
  
  <p>
    The concept of untyped constants in Go means that all the numeric constants, whether integer, floating-point, complex, or even character values,


    live in a kind of unified space.


    It&#39;s when we bring them to the computational world of variables, assignments, and operations that the actual types matter.


    But as long as we stay in the world of numeric constants, we can mix and match values as we like.


    All these constants have numeric value 1:
  </p>
  

  
  <div class="code"><pre>1
1.000
1e3-99.0*10-9
&#39;\x01&#39;
&#39;\u0001&#39;
&#39;b&#39; - &#39;a&#39;
1.0&#43;3i-3.0i</pre></div>
  

  
  <p>
    Therefore, although they have different implicit default types, written as untyped constants they can be assigned to a variable of any integer type:
  </p>
  

  
	<div class="playground">
<pre style="display: none"><span>// &#43;build OMIT

package main

import &#34;fmt&#34;

func main() {
</span></pre>

<pre contenteditable="true" spellcheck="false"><span num="9">    var f float32 = 1</span>
<span num="10">    var i int = 1.000</span>
<span num="11">    var u uint32 = 1e3 - 99.0*10.0 - 9</span>
<span num="12">    var c float64 = &#39;\x01&#39;</span>
<span num="13">    var p uintptr = &#39;\u0001&#39;</span>
<span num="14">    var r complex64 = &#39;b&#39; - &#39;a&#39;</span>
<span num="15">    var b byte = 1.0 &#43; 3i - 3.0i</span>
<span num="16"></span>
<span num="17">    fmt.Println(f, i, u, c, p, r, b)</span>
</pre>

<pre style="display: none"><span>}
</span></pre>
</div>
  

  
  <p>
    The output from this snippet is: <code>1 1 1 1 1 (1+0i) 1</code>.
  </p>
  

  
  <p>
    You can even do nutty stuff like
  </p>
  

  
	<div class="playground">
<pre style="display: none"><span>// &#43;build OMIT

package main

import &#34;fmt&#34;

func main() {
</span></pre>

<pre contenteditable="true" spellcheck="false"><span num="9">    var f = &#39;a&#39; * 1.5</span>
<span num="10">    fmt.Println(f)</span>
</pre>

<pre style="display: none"><span>}
</span></pre>
</div>
  

  
  <p>
    which yields 145.5, which is pointless except to prove a point.
  </p>
  

  
  <p>
    But the real point of these rules is flexibility.


    That flexibility means that, despite the fact that in Go it is illegal in the same expression to mix floating-point and integer variables,


    or even <code>int</code> and <code>int32</code> variables, it is fine to write
  </p>
  

  
  <div class="code"><pre>sqrt2 := math.Sqrt(2)</pre></div>
  

  
  <p>
    or
  </p>
  

  
  <div class="code"><pre>const millisecond = time.Second/1e3</pre></div>
  

  
  <p>
    or
  </p>
  

  
  <div class="code"><pre>bigBufferWithHeader := make([]byte, 512&#43;1e6)</pre></div>
  

  
  <p>
    and have the results mean what you expect.
  </p>
  

  
  <p>
    Because in Go, numeric constants work as you expect: like numbers.
  </p>
  


    
  


		
			<p class="author">By Rob Pike</p>
		
	</div>

	
		
	<div class="article">
		<h3 class="title"><a href="/osconreport">Go at OSCON</a></h3>
		<p class="date">20 August 2014</p>
		

  
  
    
      
  <h4 id="TOC_1.">Introduction</h4>
  
  
  <p>
    What happens in Portland in July? <a href="http://www.oscon.com/oscon2014" target="_blank">OSCON</a>! At


    this year&#39;s conference, Go was more present than ever before, with five talks,


    two workshops, a


    <a href="http://en.wikipedia.org/wiki/Birds_of_a_feather_(computing)" target="_blank">Birds of a Feather</a>


    session, and a meetup.
  </p>
  


    
      
  <h4 id="TOC_2.">Talks</h4>
  
  
  <p>
    <a href="http://twitter.com/mstine" target="_blank">Matt Stine</a> talked about his experience switching


    from Java to Go with


    <a href="http://www.slideshare.net/mstine/java-devlearnstogooscon" target="_blank">A recovering Java developer learns Go</a>


    while <a href="https://twitter.com/spf13" target="_blank">Steve Francia</a> presented


    <a href="http://spf13.com/presentation/MongoDB-and-Go" target="_blank">Painless Data Storage with MongoDB and Go</a>.


    Steve also presented


    <a href="http://spf13.com/presentation/go-for-object-oriented-programmers" target="_blank">Go for Object Oriented Programmers</a>,


    where he explained how some object oriented concepts can be implemented in Go.
  </p>
  

<div class="image">
  <img src="osconreport/talks.png" width="800">
</div>

  
  <p>
    Finally, <a href="http://twitter.com/offbymany" target="_blank">Josh Bleecher Snyder</a> talked about his


    experience writing tools to work with Go source code in


    <a href="https://talks.golang.org/2014/hammers.slide#1" target="_blank">Gophers with hammers</a>,


    and <a href="http://twitter.com/francesc" target="_blank">Francesc Campoy</a> talked about all the things


    that could have gone wrong and what the Go team did to prevent them


    <a href="http://talks.golang.org/2014/playground.slide" target="_blank">Inside the Go playground</a>.
  </p>
  


    
      
  <h4 id="TOC_3.">Workshops</h4>
  
  
  <p>
    At the beginning of OSCON&#39;s workshop day, Steve Francia presented how to build a


    web application and a CLI tool during


    <a href="http://spf13.com/presentation/first-go-app" target="_blank">Getting started with Go</a> to a big


    room full of Gophers.
  </p>
  

<div class="image">
  <img src="osconreport/workshops.png" width="800">
</div>

  
  <p>
    In the afternoon, <a href="https://twitter.com/mmceniry" target="_blank">Chris McEniry</a> gave his


    <a href="http://cdn.oreillystatic.com/en/assets/1/event/115/A%20Quick%20Introduction%20to%20System%20Tools%20Programming%20with%20Go%20Presentation.pdf" target="_blank">Quick introduction to system tools programming with Go</a> where he went over some useful skills to


    write system tools using Go and its standard library.
  </p>
  


    
      
  <h4 id="TOC_4.">Additional events</h4>
  
  
  <p>
    To take advantage of the increased Gopher population in Portland during OSCON, we


    organized two extra events: the first <a href="https://twitter.com/pdxgolang" target="_blank">PDXGolang</a>


    meetup and a


    <a href="http://www.oscon.com/oscon2014/public/schedule/detail/37775" target="_blank">Birds of a Feather session</a>.
  </p>
  

<div class="image">
  <img src="osconreport/meetup.png" width="800">
</div>

  
  <p>
    At the meetup Francesc Campoy talked about


    <a href="http://talks.golang.org/2013/bestpractices.slide" target="_blank">Go Best Practices</a> and


    <a href="https://twitter.com/kelseyhightower" target="_blank">Kelsey Hightower</a> gave a great


    introduction to <a href="https://github.com/GoogleCloudPlatform/kubernetes" target="_blank">Kubernetes</a>,


    a container management system for clusters written in Go by Google. If you live


    in Portland, make sure you <a href="http://meetup.com/pdx-go" target="_blank">join the group</a> and come


    along to the next meeting.
  </p>
  

  
  <p>
    The &#34;Birds of a Feather&#34; (or, more aptly, &#34;Gophers of a Feather&#34;) was a lot of


    fun for everyone involved. We hope to see more of you there next year.
  </p>
  


    
      
  <h4 id="TOC_5.">In conclusion</h4>
  
<div class="image">
  <img src="osconreport/random.png" width="800">
</div>

  
  <p>
    Thanks to all the gophers that participated in OSCON. After the successes of


    this year we look forward to more Go fun at OSCON 2015.
  </p>
  


    
  


		
			<p class="author">By Francesc Campoy</p>
		
	</div>

	
		
	<div class="article">
		<h3 class="title"><a href="/context">Go Concurrency Patterns: Context</a></h3>
		<p class="date">29 July 2014</p>
		

  
  
    
      
  <h4 id="TOC_1.">Introduction</h4>
  
  
  <p>
    In Go servers, each incoming request is handled in its own goroutine.


    Request handlers often start additional goroutines to access backends such as


    databases and RPC services.


    The set of goroutines working on a request typically needs access to


    request-specific values such as the identity of the end user, authorization


    tokens, and the request&#39;s deadline.


    When a request is canceled or times out, all the goroutines working on that


    request should exit quickly so the system can reclaim any resources they are


    using.
  </p>
  

  
  <p>
    At Google, we developed a <code>context</code> package that makes it easy to pass


    request-scoped values, cancelation signals, and deadlines across API boundaries


    to all the goroutines involved in handling a request.


    The package is publicly available as


    <a href="http://godoc.org/code.google.com/p/go.net/context" target="_blank">code.google.com/p/go.net/context</a>.


    This article describes how to use the package and provides a complete working


    example.
  </p>
  


    
      
  <h4 id="TOC_2.">Context</h4>
  
  
  <p>
    The core of the <code>context</code> package is the <code>Context</code> type:
  </p>
  

  
	<div class="code">


<pre><span num="7">// A Context carries a deadline, cancelation signal, and request-scoped values</span>
<span num="8">// across API boundaries. Its methods are safe for simultaneous use by multiple</span>
<span num="9">// goroutines.</span>
<span num="10">type Context interface {</span>
<span num="11">    // Done returns a channel that is closed when this Context is canceled</span>
<span num="12">    // or times out.</span>
<span num="13">    Done() &lt;-chan struct{}</span>
<span num="14"></span>
<span num="15">    // Err indicates why this context was canceled, after the Done channel</span>
<span num="16">    // is closed.</span>
<span num="17">    Err() error</span>
<span num="18"></span>
<span num="19">    // Deadline returns the time when this Context will be canceled, if any.</span>
<span num="20">    Deadline() (deadline time.Time, ok bool)</span>
<span num="21"></span>
<span num="22">    // Value returns the value associated with key or nil if none.</span>
<span num="23">    Value(key interface{}) interface{}</span>
<span num="24">}</span>
</pre>


</div>
  

  
  <p>
    (This description is condensed; the


    <a href="http://godoc.org/code.google.com/p/go.net/context" target="_blank">godoc</a> is authoritative.)
  </p>
  

  
  <p>
    The <code>Done</code> method returns a channel that acts as a cancelation signal to


    functions running on behalf of the <code>Context</code>: when the channel is closed, the


    functions should abandon their work and return.


    The <code>Err</code> method returns an error indicating why the <code>Context</code> was canceled.


    The <a href="/pipelines" target="_self">Pipelines and Cancelation</a> article discusses the <code>Done</code>


    channel idiom in more detail.
  </p>
  

  
  <p>
    A <code>Context</code> does <i>not</i> have a <code>Cancel</code> method for the same reason the <code>Done</code>


    channel is receive-only: the function receiving a cancelation signal is usually


    not the one that sends the signal.


    In particular, when a parent operation starts goroutines for sub-operations,


    those sub-operations should not be able to cancel the parent.


    Instead, the <code>WithCancel</code> function (described below) provides a way to cancel a


    new <code>Context</code> value.
  </p>
  

  
  <p>
    A <code>Context</code> is safe for simultaneous use by multiple goroutines.


    Code can pass a single <code>Context</code> to any number of goroutines and cancel that


    <code>Context</code> to signal all of them.
  </p>
  

  
  <p>
    The <code>Deadline</code> method allows functions to determine whether they should start


    work at all; if too little time is left, it may not be worthwhile.


    Code may also use a deadline to set timeouts for I/O operations.
  </p>
  

  
  <p>
    <code>Value</code> allows a <code>Context</code> to carry request-scoped data.


    That data must be safe for simultaneous use by multiple goroutines.
  </p>
  

  <h4 id="TOC_2.1.">Derived contexts</h4>
  
  
  <p>
    The <code>context</code> package provides functions to <i>derive</i> new <code>Context</code> values from


    existing ones.


    These values form a tree: when a <code>Context</code> is canceled, all <code>Contexts</code> derived


    from it are also canceled.
  </p>
  

  
  <p>
    <code>Background</code> is the root of any <code>Context</code> tree; it is never canceled:
  </p>
  

  
	<div class="code">


<pre><span num="43">// Background returns an empty Context. It is never canceled, has no deadline,</span>
<span num="44">// and has no values. Background is typically used in main, init, and tests,</span>
<span num="45">// and as the top-level Context for incoming requests.</span>
<span num="46">func Background() Context</span>
</pre>


</div>
  

  
  <p>
    <code>WithCancel</code> and <code>WithTimeout</code> return derived <code>Context</code> values that can be


    canceled sooner than the parent <code>Context</code>.


    The <code>Context</code> associated with an incoming request is typically canceled when the


    request handler returns.


    <code>WithCancel</code> is also useful for canceling redundant requests when using multiple


    replicas.


    <code>WithTimeout</code> is useful for setting a deadline on requests to backend servers:
  </p>
  

  
	<div class="code">


<pre><span num="26">// WithCancel returns a copy of parent whose Done channel is closed as soon as</span>
<span num="27">// parent.Done is closed or cancel is called.</span>
<span num="28">func WithCancel(parent Context) (ctx Context, cancel CancelFunc)</span>
<span num="29"></span>
<span num="30">// A CancelFunc cancels a Context.</span>
<span num="31">type CancelFunc func()</span>
<span num="32"></span>
<span num="33">// WithTimeout returns a copy of parent whose Done channel is closed as soon as</span>
<span num="34">// parent.Done is closed, cancel is called, or timeout elapses. The new</span>
<span num="35">// Context&#39;s Deadline is the sooner of now&#43;timeout and the parent&#39;s deadline, if</span>
<span num="36">// any. If the timer is still running, the cancel function releases its</span>
<span num="37">// resources.</span>
<span num="38">func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)</span>
</pre>


</div>
  

  
  <p>
    <code>WithValue</code> provides a way to associate request-scoped values with a <code>Context</code>:
  </p>
  

  
	<div class="code">


<pre><span num="40">// WithValue returns a copy of parent whose Value method returns val for key.</span>
<span num="41">func WithValue(parent Context, key interface{}, val interface{}) Context</span>
</pre>


</div>
  

  
  <p>
    The best way to see how to use the <code>context</code> package is through a worked


    example.
  </p>
  



    
      
  <h4 id="TOC_3.">Example: Google Web Search</h4>
  
  
  <p>
    Our example is an HTTP server that handles URLs like


    <code>/search?q=golang&amp;timeout=1s</code> by forwarding the query &#34;golang&#34; to the


    <a href="https://developers.google.com/web-search/docs/" target="_blank">Google Web Search API</a> and


    rendering the results.


    The <code>timeout</code> parameter tells the server to cancel the request after that


    duration elapses.
  </p>
  

  
  <p>
    The code is split across three packages:
  </p>
  

  <ul>
  
    <li><a href="context/server/server.go" target="_self">server</a> provides the <code>main</code> function and the handler for <code>/search</code>.</li>
  
    <li><a href="context/userip/userip.go" target="_self">userip</a> provides functions for extracting a user IP address from a request and associating it with a <code>Context</code>.</li>
  
    <li><a href="context/google/google.go" target="_self">google</a> provides the <code>Search</code> function for sending a query to Google.</li>
  
  </ul>

  <h4 id="TOC_3.1.">The server program</h4>
  
  
  <p>
    The <a href="context/server/server.go" target="_self">server</a> program handles requests like


    <code>/search?q=golang</code> by serving the first few Google search results for <code>golang</code>.


    It registers <code>handleSearch</code> to handle the <code>/search</code> endpoint.


    The handler creates an initial <code>Context</code> called <code>ctx</code> and arranges for it to be


    canceled when the handler returns.


    If the request includes the <code>timeout</code> URL parameter, the <code>Context</code> is canceled


    automatically when the timeout elapses:
  </p>
  

  
	<div class="code">


<pre><span num="32">func handleSearch(w http.ResponseWriter, req *http.Request) {</span>
<span num="33">    // ctx is the Context for this handler. Calling cancel closes the</span>
<span num="34">    // ctx.Done channel, which is the cancellation signal for requests</span>
<span num="35">    // started by this handler.</span>
<span num="36">    var (</span>
<span num="37">        ctx    context.Context</span>
<span num="38">        cancel context.CancelFunc</span>
<span num="39">    )</span>
<span num="40">    timeout, err := time.ParseDuration(req.FormValue(&#34;timeout&#34;))</span>
<span num="41">    if err == nil {</span>
<span num="42">        // The request has a timeout, so create a context that is</span>
<span num="43">        // canceled automatically when the timeout expires.</span>
<span num="44">        ctx, cancel = context.WithTimeout(context.Background(), timeout)</span>
<span num="45">    } else {</span>
<span num="46">        ctx, cancel = context.WithCancel(context.Background())</span>
<span num="47">    }</span>
<span num="48">    defer cancel() // Cancel ctx as soon as handleSearch returns.</span>
</pre>


</div>
  

  
  <p>
    The handler extracts the query from the request and extracts the client&#39;s IP


    address by calling on the <code>userip</code> package.


    The client&#39;s IP address is needed for backend requests, so <code>handleSearch</code>


    attaches it to <code>ctx</code>:
  </p>
  

  
	<div class="code">


<pre><span num="50">    // Check the search query.</span>
<span num="51">    query := req.FormValue(&#34;q&#34;)</span>
<span num="52">    if query == &#34;&#34; {</span>
<span num="53">        http.Error(w, &#34;no query&#34;, http.StatusBadRequest)</span>
<span num="54">        return</span>
<span num="55">    }</span>
<span num="56"></span>
<span num="57">    // Store the user IP in ctx for use by code in other packages.</span>
<span num="58">    userIP, err := userip.FromRequest(req)</span>
<span num="59">    if err != nil {</span>
<span num="60">        http.Error(w, err.Error(), http.StatusBadRequest)</span>
<span num="61">        return</span>
<span num="62">    }</span>
<span num="63">    ctx = userip.NewContext(ctx, userIP)</span>
</pre>


</div>
  

  
  <p>
    The handler calls <code>google.Search</code> with <code>ctx</code> and the <code>query</code>:
  </p>
  

  
	<div class="code">


<pre><span num="65">    // Run the Google search and print the results.</span>
<span num="66">    start := time.Now()</span>
<span num="67">    results, err := google.Search(ctx, query)</span>
<span num="68">    elapsed := time.Since(start)</span>
</pre>


</div>
  

  
  <p>
    If the search succeeds, the handler renders the results:
  </p>
  

  
	<div class="code">


<pre><span num="73">    if err := resultsTemplate.Execute(w, struct {</span>
<span num="74">        Results          google.Results</span>
<span num="75">        Timeout, Elapsed time.Duration</span>
<span num="76">    }{</span>
<span num="77">        Results: results,</span>
<span num="78">        Timeout: timeout,</span>
<span num="79">        Elapsed: elapsed,</span>
<span num="80">    }); err != nil {</span>
<span num="81">        log.Print(err)</span>
<span num="82">        return</span>
<span num="83">    }</span>
</pre>


</div>
  


  <h4 id="TOC_3.2.">Package userip</h4>
  
  
  <p>
    The <a href="context/userip/userip.go" target="_self">userip</a> package provides functions for


    extracting a user IP address from a request and associating it with a <code>Context</code>.


    A <code>Context</code> provides a key-value mapping, where the keys and values are both of


    type <code>interface{}</code>.


    Key types must support equality, and values must be safe for simultaneous use by


    multiple goroutines.


    Packages like <code>userip</code> hide the details of this mapping and provide


    strongly-typed access to a specific <code>Context</code> value.
  </p>
  

  
  <p>
    To avoid key collisions, <code>userip</code> defines an unexported type <code>key</code> and uses


    a value of this type as the context key:
  </p>
  

  
	<div class="code">


<pre><span num="27">// The key type is unexported to prevent collisions with context keys defined in</span>
<span num="28">// other packages.</span>
<span num="29">type key int</span>
<span num="30"></span>
<span num="31">// userIPkey is the context key for the user IP address.  Its value of zero is</span>
<span num="32">// arbitrary.  If this package defined other context keys, they would have</span>
<span num="33">// different integer values.</span>
<span num="34">const userIPKey key = 0</span>
</pre>


</div>
  

  
  <p>
    <code>FromRequest</code> extracts a <code>userIP</code> value from an <code>http.Request</code>:
  </p>
  

  
	<div class="code">


<pre><span num="14">func FromRequest(req *http.Request) (net.IP, error) {</span>
<span num="15">    ip, _, err := net.SplitHostPort(req.RemoteAddr)</span>
<span num="16">    if err != nil {</span>
<span num="17">        return nil, fmt.Errorf(&#34;userip: %q is not IP:port&#34;, req.RemoteAddr)</span>
<span num="18">    }</span>
</pre>


</div>
  

  
  <p>
    <code>NewContext</code> returns a new <code>Context</code> that carries a provided <code>userIP</code> value:
  </p>
  

  
	<div class="code">


<pre><span num="37">func NewContext(ctx context.Context, userIP net.IP) context.Context {</span>
<span num="38">    return context.WithValue(ctx, userIPKey, userIP)</span>
<span num="39">}</span>
</pre>


</div>
  

  
  <p>
    <code>FromContext</code> extracts a <code>userIP</code> from a <code>Context</code>:
  </p>
  

  
	<div class="code">


<pre><span num="42">func FromContext(ctx context.Context) (net.IP, bool) {</span>
<span num="43">    // ctx.Value returns nil if ctx has no value for the key;</span>
<span num="44">    // the net.IP type assertion returns ok=false for nil.</span>
<span num="45">    userIP, ok := ctx.Value(userIPKey).(net.IP)</span>
<span num="46">    return userIP, ok</span>
<span num="47">}</span>
</pre>


</div>
  


  <h4 id="TOC_3.3.">Package google</h4>
  
  
  <p>
    The <a href="context/google/google.go" target="_self">google.Search</a> function makes an HTTP request


    to the <a href="https://developers.google.com/web-search/docs/" target="_blank">Google Web Search API</a>


    and parses the JSON-encoded result.


    It accepts a <code>Context</code> parameter <code>ctx</code> and returns immediately if <code>ctx.Done</code> is


    closed while the request is in flight.
  </p>
  

  
  <p>
    The Google Web Search API request includes the search query and the user IP as


    query parameters:
  </p>
  

  
	<div class="code">


<pre><span num="22">func Search(ctx context.Context, query string) (Results, error) {</span>
<span num="23">    // Prepare the Google Search API request.</span>
<span num="24">    req, err := http.NewRequest(&#34;GET&#34;, &#34;https://ajax.googleapis.com/ajax/services/search/web?v=1.0&#34;, nil)</span>
<span num="25">    if err != nil {</span>
<span num="26">        return nil, err</span>
<span num="27">    }</span>
<span num="28">    q := req.URL.Query()</span>
<span num="29">    q.Set(&#34;q&#34;, query)</span>
<span num="30"></span>
<span num="31">    // If ctx is carrying the user IP address, forward it to the server.</span>
<span num="32">    // Google APIs use the user IP to distinguish server-initiated requests</span>
<span num="33">    // from end-user requests.</span>
<span num="34">    if userIP, ok := userip.FromContext(ctx); ok {</span>
<span num="35">        q.Set(&#34;userip&#34;, userIP.String())</span>
<span num="36">    }</span>
<span num="37">    req.URL.RawQuery = q.Encode()</span>
</pre>


</div>
  

  
  <p>
    <code>Search</code> uses a helper function, <code>httpDo</code>, to issue the HTTP request and cancel


    it if <code>ctx.Done</code> is closed while the request or response is being processed.


    <code>Search</code> passes a closure to <code>httpDo</code> handle the HTTP response:
  </p>
  

  
	<div class="code">


<pre><span num="41">    var results Results</span>
<span num="42">    err = httpDo(ctx, req, func(resp *http.Response, err error) error {</span>
<span num="43">        if err != nil {</span>
<span num="44">            return err</span>
<span num="45">        }</span>
<span num="46">        defer resp.Body.Close()</span>
<span num="47"></span>
<span num="48">        // Parse the JSON search result.</span>
<span num="49">        // https://developers.google.com/web-search/docs/#fonje</span>
<span num="50">        var data struct {</span>
<span num="51">            ResponseData struct {</span>
<span num="52">                Results []struct {</span>
<span num="53">                    TitleNoFormatting string</span>
<span num="54">                    URL               string</span>
<span num="55">                }</span>
<span num="56">            }</span>
<span num="57">        }</span>
<span num="58">        if err := json.NewDecoder(resp.Body).Decode(&amp;data); err != nil {</span>
<span num="59">            return err</span>
<span num="60">        }</span>
<span num="61">        for _, res := range data.ResponseData.Results {</span>
<span num="62">            results = append(results, Result{Title: res.TitleNoFormatting, URL: res.URL})</span>
<span num="63">        }</span>
<span num="64">        return nil</span>
<span num="65">    })</span>
<span num="66">    // httpDo waits for the closure we provided to return, so it&#39;s safe to</span>
<span num="67">    // read results here.</span>
<span num="68">    return results, err</span>
</pre>


</div>
  

  
  <p>
    The <code>httpDo</code> function runs the HTTP request and processes its response in a new


    goroutine.


    It cancels the request if <code>ctx.Done</code> is closed before the goroutine exits:
  </p>
  

  
	<div class="code">


<pre><span num="74">func httpDo(ctx context.Context, req *http.Request, f func(*http.Response, error) error) error {</span>
<span num="75">    // Run the HTTP request in a goroutine and pass the response to f.</span>
<span num="76">    tr := &amp;http.Transport{}</span>
<span num="77">    client := &amp;http.Client{Transport: tr}</span>
<span num="78">    c := make(chan error, 1)</span>
<span num="79">    go func() { c &lt;- f(client.Do(req)) }()</span>
<span num="80">    select {</span>
<span num="81">    case &lt;-ctx.Done():</span>
<span num="82">        tr.CancelRequest(req)</span>
<span num="83">        &lt;-c // Wait for f to return.</span>
<span num="84">        return ctx.Err()</span>
<span num="85">    case err := &lt;-c:</span>
<span num="86">        return err</span>
<span num="87">    }</span>
<span num="88">}</span>
</pre>


</div>
  



    
      
  <h4 id="TOC_4.">Adapting code for Contexts</h4>
  
  
  <p>
    Many server frameworks provide packages and types for carrying request-scoped


    values.


    We can define new implementations of the <code>Context</code> interface to bridge between


    code using existing frameworks and code that expects a <code>Context</code> parameter.
  </p>
  

  
  <p>
    For example, Gorilla&#39;s


    <a href="http://www.gorillatoolkit.org/pkg/context" target="_blank">github.com/gorilla/context</a>


    package allows handlers to associate data with incoming requests by providing a


    mapping from HTTP requests to key-value pairs.


    In <a href="context/gorilla/gorilla.go" target="_self">gorilla.go</a>, we provide a <code>Context</code>


    implementation whose <code>Value</code> method returns the values associated with a


    specific HTTP request in the Gorilla package.
  </p>
  

  
  <p>
    Other packages have provided cancelation support similar to <code>Context</code>.


    For example, <a href="http://godoc.org/gopkg.in/tomb.v2" target="_blank">Tomb</a> provides a <code>Kill</code>


    method that signals cancelation by closing a <code>Dying</code> channel.


    <code>Tomb</code> also provides methods to wait for those goroutines to exit, similar to


    <code>sync.WaitGroup</code>.


    In <a href="context/tomb/tomb.go" target="_self">tomb.go</a>, we provide a <code>Context</code> implementation that


    is canceled when either its parent <code>Context</code> is canceled or a provided <code>Tomb</code> is


    killed.
  </p>
  


    
      
  <h4 id="TOC_5.">Conclusion</h4>
  
  
  <p>
    At Google, we require that Go programmers pass a <code>Context</code> parameter as the


    first argument to every function on the call path between incoming and outgoing


    requests.


    This allows Go code developed by many different teams to interoperate well.


    It provides simple control over timeouts and cancelation and ensures that


    critical values like security credentials transit Go programs properly.
  </p>
  

  
  <p>
    Server frameworks that want to build on <code>Context</code> should provide implementations


    of <code>Context</code> to bridge between their packages and those that expect a <code>Context</code>


    parameter.


    Their client libraries would then accept a <code>Context</code> from the calling code.


    By establishing a common interface for request-scoped data and cancelation,


    <code>Context</code> makes it easier for package developers to share code for creating


    scalable services.
  </p>
  


    
  


		
			<p class="author">By Sameer Ajmani</p>
		
	</div>

	
		
	<div class="article">
		<h3 class="title"><a href="/oscon">Go will be at OSCON 2014</a></h3>
		<p class="date">15 July 2014</p>
		

  
  
    
      
        
  
  <p>
    <a href="http://www.oscon.com" target="_blank">OSCON</a>, the Open Source Convention, is taking place


    from July 20th to the 29th in Portland, Oregon and Go will be central to many


    talks. If you are attending make sure you add these to your personal schedule.
  </p>
  

      
        
  
  <p>
    On Monday you&#39;ll have the chance to learn Go in these two tutorials:
  </p>
  

      
        
  <ul>
  
    <li><a href="http://www.oscon.com/oscon2014/public/schedule/detail/34395" target="_blank">Getting Started with Go</a> by <a href="http://twitter.com/spf13" target="_blank">Steve Francia</a> (MongoDB) at 9:00am on Monday, 07/21/2014</li>
  
  </ul>

      
        
  <ul>
  
    <li><a href="http://www.oscon.com/oscon2014/public/schedule/detail/34267" target="_blank">A Quick Introduction to System Tools Programming with Go</a> by <a href="http://twitter.com/macmceniry" target="_blank">Chris McEniry</a> (Sony Network Entertainment) at 1:30pm on Monday, 07/21/2014</li>
  
  </ul>

      
        
  
  <p>
    During the rest of the week you can hear how different projects use Go:
  </p>
  

      
        
  <ul>
  
    <li><a href="http://www.oscon.com/oscon2014/public/schedule/detail/34371" target="_blank">A Recovering Java Developer Learns to Go</a> by <a href="http://twitter.com/mstine" target="_blank">Matt Stine</a> (Pivotal) at 1:40pm on Tuesday, 07/22/2014</li>
  
  </ul>

      
        
  <ul>
  
    <li><a href="http://www.oscon.com/oscon2014/public/schedule/detail/34299" target="_blank">Painless Data Storage with MongoDB and Go</a> by <a href="http://twitter.com/spf13" target="_blank">Steve Francia</a> (MongoDB) and <a href="http://twitter.com/gniemeyer" target="_blank">Gustavo Niemeyer</a> (Canonical) at 1:40pm on Tuesday, 07/22/2014</li>
  
  </ul>

      
        
  <ul>
  
    <li><a href="http://www.oscon.com/oscon2014/public/schedule/detail/37795" target="_blank">Gophers with Hammers: Fun with Parsing and Generating Go</a> by <a href="http://twitter.com/offbymany" target="_blank">Josh Bleecher Snyder</a> (PayPal) at 2:30pm on Tuesday, 07/22/2014</li>
  
  </ul>

      
        
  <ul>
  
    <li><a href="http://www.oscon.com/oscon2014/public/schedule/detail/34047" target="_blank">Go for Object Oriented Programmers (or OO Programming without Objects)</a> by <a href="http://twitter.com/spf13" target="_blank">Steve Francia</a> (MongoDB) at 4:10pm on Wednesday, 07/23/2014</li>
  
  </ul>

      
        
  <ul>
  
    <li><a href="http://www.oscon.com/oscon2014/public/schedule/detail/34509" target="_blank">Inside the Go Tour</a> by <a href="http://twitter.com/francesc" target="_blank">Francesc Campoy Flores</a> (Google Inc.) at 11:50am on Thursday, 07/24/2014</li>
  
  </ul>

      
        
  
  <p>
    And if you have any questions come to the


    <a href="http://www.oscon.com/oscon2014/public/schedule/detail/37075" target="_blank">Go office hours</a>


    on Wednesday or come anytime by the Google booth.
  </p>
  

      
        
  
  <p>
    See you at OSCON!
  </p>
  

      
    
  


		
			<p class="author">By Francesc Campoy</p>
		
	</div>

	
		
	<div class="article">
		<h3 class="title"><a href="/go1.3">Go 1.3 is released</a></h3>
		<p class="date">18 June 2014</p>
		

  
  
    
      
        
  
  <p>
    Today we are happy to announce the release of <a href="http://golang.org/doc/go1.3" target="_blank">Go 1.3</a>.


    This release comes six months after our last major release and provides better


    performance, improved tools, support for running Go in new environments, and more.


    All Go users should upgrade to Go 1.3.


    You can grab the release from our <a href="http://golang.org/dl/" target="_blank">downloads page</a> and


    find the full list of improvements and fixes in the


    <a href="http://golang.org/doc/go1.3" target="_blank">release notes</a>.


    What follows are some highlights.
  </p>
  

      
        
  
  <p>
    <a href="http://godoc.org/code.google.com/p/go.tools/cmd/godoc" target="_blank">Godoc</a>,


    the Go documentation server, now performs static analysis.


    When enabled with the -analysis flag, analysis results are presented


    in both the source and package documentation views, making it easier


    than ever to navigate and understand Go programs.


    See <a href="http://golang.org/lib/godoc/analysis/help.html" target="_blank">the documentation</a> for the details.
  </p>
  

      
        
  
  <p>
    The gc toolchain now supports the Native Client (NaCl) execution sandbox on the


    32- and 64-bit Intel architectures.


    This permits the safe execution of untrusted code, useful in environments such as the


    <a href="http://blog.golang.org/playground" target="_blank">Playground</a>.


    To set up NaCl on your system see the <a href="http://golang.org/wiki/NativeClient" target="_blank">NativeClient wiki page</a>.
  </p>
  

      
        
  
  <p>
    Also included in this release is experimental support for the DragonFly BSD,


    Plan 9, and Solaris operating systems. To use Go on these systems you must


    <a href="http://golang.org/doc/install/source" target="_blank">install from source</a>.
  </p>
  

      
        
  
  <p>
    Changes to the runtime have improved the


    <a href="http://golang.org/doc/go1.3#performance" target="_blank">performance</a> of Go binaries,


    with an improved garbage collector, a new


    <a href="http://golang.org/s/contigstacks" target="_blank">&#34;contiguous&#34; goroutine stack management strategy</a>,


    a faster race detector, and improvements to the regular expression engine.
  </p>
  

      
        
  
  <p>
    As part of the general <a href="http://golang.org/s/go13linker" target="_blank">overhaul</a> of the Go


    linker, the compilers and linkers have been refactored. The instruction


    selection phase that was part of the linker has been moved to the compiler.


    This can speed up incremental builds for large projects.
  </p>
  

      
        
  
  <p>
    The <a href="http://golang.org/doc/go1.3#garbage_collector" target="_blank">garbage collector</a> is now


    precise when examining stacks (collection of the heap has been precise since Go


    1.1), meaning that a non-pointer value such as an integer will never be


    mistaken for a pointer and prevent unused memory from being reclaimed. This


    change affects code that uses package unsafe; if you have unsafe code you


    should read the <a href="http://golang.org/doc/go1.3#garbage_collector" target="_blank">release notes</a>


    carefully to see if your code needs updating.
  </p>
  

      
        
  
  <p>
    We would like to thank the many people who contributed to this release;


    it would not have been possible without your help.
  </p>
  

      
        
  
  <p>
    So, what are you waiting for?


    Head on over to the <a href="http://golang.org/dl/" target="_blank">downloads page</a> and start hacking.
  </p>
  

      
    
  


		
			<p class="author">By Andrew Gerrand</p>
		
	</div>

	
	<p>See the <a href="/index">index</a> for more articles.

</div>

<div id="footer">
	<p>
	Except as
	<a href="https://developers.google.com/site-policies#restrictions">noted</a>,
	the content of this page is licensed under the Creative Commons
	Attribution 3.0 License,<br>
	and code is licensed under a <a href="//golang.org/LICENSE">BSD license</a>.<br>
	<a href="//golang.org/doc/tos.html">Terms of Service</a> | 
	<a href="//www.google.com/intl/en/policies/privacy/">Privacy Policy</a>
	</p>
</div>

</div>
</div>

<script type="text/javascript">
(function() {
  var ga = document.createElement("script"); ga.type = "text/javascript"; ga.async = true;
  ga.src = ("https:" == document.location.protocol ? "https://ssl" : "http://www") + ".google-analytics.com/ga.js";
  var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
</body>
<script src="/lib/godoc/jquery.js"></script>
<script src="/lib/godoc/playground.js"></script>
<script src="/lib/godoc/play.js"></script>
<script src="/lib/godoc/godocs.js"></script>
<script>
$(function() {
	
	$('.playground > pre.numbers, .code > pre.numbers').each(function() {
		var $spans = $(this).find('> span');

		
		var max = 0;
		$spans.each(function() {
			var n = $(this).attr('num')*1;
			if (n > max) max = n;
		});
		var width = 2;
		while (max > 10) {
			max = max / 10;
			width++;
		}

		
		$spans.each(function() {
			var n = $(this).attr('num')+' ';
			while (n.length < width) n = ' '+n;
			$('<span class="number">').text(n).insertBefore(this);
		});
	});

	initPlayground(new HTTPTransport());
});
</script>
</html>
